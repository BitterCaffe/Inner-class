# Inner-class
###### 一、匿名内部类
######## 1、匿名内部类的使用场景、解决了什么问题、有什么优势。
######## 2、匿名内部类在方法回调中用的比价多，而且一般是调用比较少的，如果调用比较多内次创建一个对象那比较浪费内存和性能不合适。

##### 二、私有内部类
####### 1、私有内部类服务于外部寄宿类。
####### 2、私有内部类是私有的除了外部类，其他类中无法定义。
####### 3、私有内部类作为方法参数传递到其他外部类之后可以调用私有内部类的public 方法继续访问外部类的私有属性。

##### 三、私有内部类实现接口或继承public 抽闲类
####### 1、和二中一样私有内部类只能在寄宿外部类中定义、创建但是当实现接口或继承public的抽象类之后在非寄宿外部类中可以定义接口或抽象类引用变量而从寄宿内部类中创建私有内部类并通过非寄宿外部类的构造函数传递私有内部类，这样在外部类中就可以使用私有内部类了。
####### 2、这中用法在java的动态代理WeakCache 、Proxy中使用的很多。

##### 四、静态内部类（ThreadLocal、ThreadLocalMap、Entry 源码学习）
####### 1、静态内部类创建对象不依赖寄宿外部类对象
####### 2、静态内部类不能访问寄宿外部类的非静态属性、静态方法
####### 3、静态内部类中能定义静态变量、非静态变量、静态方法、非静态方法、静态内部类,非静态内部类中不能定义静态变量、静态方法、静态代码块
####### 4、静态内部类的创建不会初始化外部类，只有静态内部类调用了外部类的static方法、变量才会被初始化
####### 5、从JVM的角度来分析，内部类、静态内部类都是外部类的attributes属性中的 InnerClasses属性，但是静态内部类的上面几个特性所以静态内部类对象的创建是不依赖外部对象，因为不能访问外部类对象的信息所以也就不用创建外部类对象，只需要加载外部类获取外部类的元数据就OK。

##### 五、抽象静态内部类


##### 六、实现抽象静态内部类的内部类



